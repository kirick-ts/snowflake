var w=Object.create;var{defineProperty:S,getPrototypeOf:m,getOwnPropertyNames:k}=Object;var d=Object.prototype.hasOwnProperty;var f=(q,J,K)=>{K=q!=null?w(m(q)):{};const W=J||!q||!q.__esModule?S(K,"default",{value:q,enumerable:!0}):K;for(let Y of k(q))if(!d.call(W,Y))S(W,Y,{get:()=>q[Y],enumerable:!0});return W};var c=(q,J)=>()=>(J||q((J={exports:{}}).exports,J),J.exports);var p=c((a,x)=>{var n=function(q){if(q.length>=255)throw new TypeError("Alphabet too long");var J=new Uint8Array(256);for(var K=0;K<J.length;K++)J[K]=255;for(var W=0;W<q.length;W++){var Y=q.charAt(W),I=Y.charCodeAt(0);if(J[I]!==255)throw new TypeError(Y+" is ambiguous");J[I]=W}var X=q.length,Z=q.charAt(0),P=Math.log(X)/Math.log(256),y=Math.log(256)/Math.log(X);function b(Q){if(Q instanceof Uint8Array);else if(ArrayBuffer.isView(Q))Q=new Uint8Array(Q.buffer,Q.byteOffset,Q.byteLength);else if(Array.isArray(Q))Q=Uint8Array.from(Q);if(!(Q instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(Q.length===0)return"";var $=0,R=0,D=0,G=Q.length;while(D!==G&&Q[D]===0)D++,$++;var N=(G-D)*y+1>>>0,V=new Uint8Array(N);while(D!==G){var U=Q[D],O=0;for(var F=N-1;(U!==0||O<R)&&F!==-1;F--,O++)U+=256*V[F]>>>0,V[F]=U%X>>>0,U=U/X>>>0;if(U!==0)throw new Error("Non-zero carry");R=O,D++}var C=N-R;while(C!==N&&V[C]===0)C++;var L=Z.repeat($);for(;C<N;++C)L+=q.charAt(V[C]);return L}function T(Q){if(typeof Q!=="string")throw new TypeError("Expected String");if(Q.length===0)return new Uint8Array;var $=0,R=0,D=0;while(Q[$]===Z)R++,$++;var G=(Q.length-$)*P+1>>>0,N=new Uint8Array(G);while(Q[$]){var V=J[Q.charCodeAt($)];if(V===255)return;var U=0;for(var O=G-1;(V!==0||U<D)&&O!==-1;O--,U++)V+=X*N[O]>>>0,N[O]=V%256>>>0,V=V/256>>>0;if(V!==0)throw new Error("Non-zero carry");D=U,$++}var F=G-D;while(F!==G&&N[F]===0)F++;var C=new Uint8Array(R+(G-F)),L=R;while(F!==G)C[L++]=N[F++];return C}function u(Q){var $=T(Q);if($)return $;throw new Error("Non-base"+X+" character")}return{encode:b,decodeUnsafe:T,decode:u}};x.exports=n});class M extends Error{}class j extends M{constructor(){super("Cannot create snowflake due to increment overflow.")}}function B(q){let J="";for(let K of new Uint8Array(q)){if(K<16)J+="0";J+=K.toString(16)}return J}function g(q){const J=new Uint8Array(q.length/2);for(let K=0,W=0;K<q.length;K+=2,W++)J[W]=Number.parseInt(q.slice(K,K+2),16);return J.buffer}var E=f(p(),1),h=E.default("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");var v=1640995200000,z=1024;class H{#W;#X;#K;#J;#q;#Q;#Y;#Z;#$;constructor(...q){switch(q.length){case 5:this.#V(...q);break;case 3:this.#D(...q);break;default:throw new TypeError("Invalid arguments given.")}}#V(q,J,K,W,{increment_bit_offset:Y,number_server_id_worker_id:I}){const X=q-v;this.#q=new ArrayBuffer(8);const Z=new DataView(this.#q);Z.setUint32(0,Math.floor(X/z)),Z.setUint32(4,X%z<<22|J<<Y|I),this.#W=q,this.#X=J,this.#K=K,this.#J=W}#D(q,J,{server_id_mask:K,worker_id_bits:W,worker_id_mask:Y,increment_bit_offset:I}){if(q instanceof ArrayBuffer)this.#q=q;else if(Buffer.isBuffer(q))this.#q=q.buffer.slice(q.offset,q.offset+q.byteLength);else if(typeof q==="bigint")this.#q=new ArrayBuffer(8),new DataView(this.#q).setBigUint64(0,q);else if(typeof q==="string")switch(J){case"decimal":this.#q=new ArrayBuffer(8),new DataView(this.#q).setBigUint64(0,BigInt(q));break;case"hex":this.#q=g(q);break;case"base62":this.#q=h.decode(q).buffer;break}if(this.#q===void 0)throw new M(`Unknown encoding: ${J}`);const X=new DataView(this.#q),Z=X.getUint32(4);this.#W=X.getUint32(0)*z+(Z>>>22)+v,this.#X=Z<<10>>>10>>>I,this.#K=Z>>>W&K,this.#J=Z&Y}get timestamp(){return this.#W}get increment(){return this.#X}get server_id(){return this.#K}get worker_id(){return this.#J}get array_buffer(){return this.#q}get uint8_array(){if(!this.#Q)this.#Q=new Uint8Array(this.#q);return this.#Q}get buffer(){return Buffer.from(this.#q)}get bigint(){if(!this.#Y)this.#Y=new DataView(this.#q).getBigUint64(0);return this.#Y}get decimal(){return this.bigint.toString()}get hex(){if(!this.#Z)this.#Z=B(this.#q);return this.#Z}get base62(){if(!this.#$)this.#$=h.encode(this.uint8_array);return this.#$}}async function A(q){return new Promise((J)=>{setTimeout(J,q)})}class l{#W;#X;#K=0;#J=0;#q;#Q;constructor({bit_count:{server_id:q=7,worker_id:J=5}={},server_id:K=0,worker_id:W=0}={}){this.#W=K,this.#X=W;const Y=2**q-1,I=J,X=2**J-1;if(K<0||K>Y||!Number.isInteger(K))throw new M(`Invalid server_id: ${K} (possible values: from 0 to ${Y} inclusive)`);if(W<0||W>X||!Number.isInteger(W))throw new M(`Invalid worker_id: ${W} (possible values: from 0 to ${X} inclusive)`);const Z=q+J;this.#q=2**(22-Z)-1,this.#Q={server_id_mask:Y,worker_id_bits:I,worker_id_mask:X,increment_bit_offset:Z,number_server_id_worker_id:K<<J|W}}create(){const q=Date.now();if(q<this.#J)throw new M(`Cannot create snowflake: Date.now() has returned (probably) invalid value ${q}, but previously we got ${this.#J}, is code running on time machine?`);if(q>this.#J)this.#K=0,this.#J=q;else if(this.#K>this.#q)throw new j;return new H(q,this.#K++,this.#W,this.#X,this.#Q)}async createSafe(){for(let q=0;q<100;q++)try{return this.create()}catch(J){if(J instanceof j)await A()}throw new j}parse(q,J){return new H(q,J,this.#Q)}}export{j as SnowflakeIncrementOverflowError,l as SnowflakeFactory,M as SnowflakeError};
