var u=Object.create;var{defineProperty:S,getPrototypeOf:k,getOwnPropertyNames:w}=Object;var d=Object.prototype.hasOwnProperty;var c=(J,K,Q)=>{Q=J!=null?u(k(J)):{};const V=K||!J||!J.__esModule?S(Q,"default",{value:J,enumerable:!0}):Q;for(let Z of w(J))if(!d.call(V,Z))S(V,Z,{get:()=>J[Z],enumerable:!0});return V};var f=(J,K)=>()=>(K||J((K={exports:{}}).exports,K),K.exports);var E=f((s,B)=>{var t=function(J){if(J.length>=255)throw new TypeError("Alphabet too long");var K=new Uint8Array(256);for(var Q=0;Q<K.length;Q++)K[Q]=255;for(var V=0;V<J.length;V++){var Z=J.charAt(V),G=Z.charCodeAt(0);if(K[G]!==255)throw new TypeError(Z+" is ambiguous");K[G]=V}var W=J.length,Y=J.charAt(0),N=Math.log(W)/Math.log(256),l=Math.log(256)/Math.log(W);function m(X){if(X instanceof Uint8Array);else if(ArrayBuffer.isView(X))X=new Uint8Array(X.buffer,X.byteOffset,X.byteLength);else if(Array.isArray(X))X=Uint8Array.from(X);if(!(X instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(X.length===0)return"";var q=0,j=0,$=0,C=X.length;while($!==C&&X[$]===0)$++,q++;var I=(C-$)*l+1>>>0,F=new Uint8Array(I);while($!==C){var O=X[$],M=0;for(var D=I-1;(O!==0||M<j)&&D!==-1;D--,M++)O+=256*F[D]>>>0,F[D]=O%W>>>0,O=O/W>>>0;if(O!==0)throw new Error("Non-zero carry");j=M,$++}var U=I-j;while(U!==I&&F[U]===0)U++;var H=Y.repeat(q);for(;U<I;++U)H+=J.charAt(F[U]);return H}function z(X){if(typeof X!=="string")throw new TypeError("Expected String");if(X.length===0)return new Uint8Array;var q=0,j=0,$=0;while(X[q]===Y)j++,q++;var C=(X.length-q)*N+1>>>0,I=new Uint8Array(C);while(X[q]){var F=K[X.charCodeAt(q)];if(F===255)return;var O=0;for(var M=C-1;(F!==0||O<$)&&M!==-1;M--,O++)F+=W*I[M]>>>0,I[M]=F%256>>>0,F=F/256>>>0;if(F!==0)throw new Error("Non-zero carry");$=O,q++}var D=C-$;while(D!==C&&I[D]===0)D++;var U=new Uint8Array(j+(C-D)),H=j;while(D!==C)U[H++]=I[D++];return U}function b(X){var q=z(X);if(q)return q;throw new Error("Non-base"+W+" character")}return{encode:m,decodeUnsafe:z,decode:b}};B.exports=t});class R extends Error{}class P extends R{constructor(){super("Cannot create snowflake due to increment overflow.")}}function h(J){let K="";for(let Q of new Uint8Array(J)){if(Q<16)K+="0";K+=Q.toString(16)}return K}function p(J){const K=new Uint8Array(J.length/2);for(let Q=0,V=0;Q<J.length;Q+=2,V++)K[V]=Number.parseInt(J.slice(Q,Q+2),16);return K.buffer}var g=c(E(),1),T=g.default("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");var A=1640995200000,x=1024;class L{timestamp;server_id;worker_id;increment;#J;#K;constructor(J,K,{timestamp:Q,server_id:V,worker_id:Z,increment:G}){this.#J=J,this.#K=K,this.timestamp=Q,this.server_id=V,this.worker_id=Z,this.increment=G}static fromValues({timestamp:J,server_id:K,worker_id:Q,increment:V},{increment_bit_offset:Z,number_server_id_worker_id:G}){const W=J-A,Y=new ArrayBuffer(8),N=new DataView(Y);return N.setUint32(0,Math.floor(W/x)),N.setUint32(4,W%x<<22|V<<Z|G),new L(Y,N,{timestamp:J,server_id:K,worker_id:Q,increment:V})}static fromSnowflake(J,K,{server_id_mask:Q,worker_id_bits:V,worker_id_mask:Z,increment_bit_offset:G}){let W=null,Y=null;if(J instanceof ArrayBuffer)W=J;else if(Buffer.isBuffer(J))W=J.buffer.slice(J.byteOffset,J.byteOffset+J.byteLength);else if(typeof J==="bigint")W=new ArrayBuffer(8),Y=new DataView(W),Y.setBigUint64(0,J);else if(typeof J==="string")switch(K){case"decimal":W=new ArrayBuffer(8),Y=new DataView(W),Y.setBigUint64(0,BigInt(J));break;case"hex":W=p(J);break;case"base62":W=T.decode(J).buffer;break}if(W===null)throw new R(`Unknown encoding: ${K}`);if(Y===null)Y=new DataView(W);const N=Y.getUint32(4);return new L(W,Y,{timestamp:Y.getUint32(0)*x+(N>>>22)+A,server_id:N>>>V&Q,worker_id:N&Z,increment:N<<10>>>10>>>G})}toArrayBuffer(){return this.#J}toUint8Array(){return new Uint8Array(this.#J)}toBuffer(){return Buffer.from(this.#J)}toBigInt(){return this.#K.getBigUint64(0)}toDecimal(){return this.toBigInt().toString()}toHex(){return h(this.#J)}toBase62(){return T.encode(this.toUint8Array())}}async function v(J=0){return new Promise((K)=>{setTimeout(K,J)})}class y{#J;#K;#V=0;#Q=0;#X;#W;constructor({bits:{server_id:J=7,worker_id:K=5}={},server_id:Q=0,worker_id:V=0}={}){this.#J=Q,this.#K=V;const Z=2**J-1,G=K,W=2**K-1;if(Q<0||Q>Z||!Number.isInteger(Q))throw new R(`Invalid server_id: ${Q} (possible values: from 0 to ${Z} inclusive)`);if(V<0||V>W||!Number.isInteger(V))throw new R(`Invalid worker_id: ${V} (possible values: from 0 to ${W} inclusive)`);const Y=J+K;this.#X=2**(22-Y)-1,this.#W={server_id_mask:Z,worker_id_bits:G,worker_id_mask:W,increment_bit_offset:Y,number_server_id_worker_id:Q<<K|V}}create(){const J=Date.now();if(J<this.#Q)throw new R(`Cannot create snowflake: Date.now() has returned (probably) invalid value ${J}, but previously we got ${this.#Q}, is code running on time machine?`);if(J>this.#Q)this.#V=0,this.#Q=J;else if(this.#V>this.#X)throw new P;return L.fromValues({timestamp:J,server_id:this.#J,worker_id:this.#K,increment:this.#V++},this.#W)}async createSafe(){for(;;)try{return this.create()}catch(J){if(J instanceof P)await v()}}parse(J,K){return L.fromSnowflake(J,K,this.#W)}}export{P as SnowflakeIncrementOverflowError,y as SnowflakeFactory,R as SnowflakeError,L as Snowflake};
