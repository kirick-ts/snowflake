var w=Object.create;var{defineProperty:p,getPrototypeOf:f,getOwnPropertyNames:k}=Object;var d=Object.prototype.hasOwnProperty;var c=(q,J,K)=>{K=q!=null?w(f(q)):{};const V=J||!q||!q.__esModule?p(K,"default",{value:q,enumerable:!0}):K;for(let X of k(q))if(!d.call(V,X))p(V,X,{get:()=>q[X],enumerable:!0});return V};var t=(q,J)=>()=>(J||q((J={exports:{}}).exports,J),J.exports);var v=t((i,g)=>{var n=function(q){if(q.length>=255)throw new TypeError("Alphabet too long");var J=new Uint8Array(256);for(var K=0;K<J.length;K++)J[K]=255;for(var V=0;V<q.length;V++){var X=q.charAt(V),I=X.charCodeAt(0);if(J[I]!==255)throw new TypeError(X+" is ambiguous");J[I]=V}var W=q.length,Y=q.charAt(0),h=Math.log(W)/Math.log(256),b=Math.log(256)/Math.log(W);function m(Q){if(Q instanceof Uint8Array);else if(ArrayBuffer.isView(Q))Q=new Uint8Array(Q.buffer,Q.byteOffset,Q.byteLength);else if(Array.isArray(Q))Q=Uint8Array.from(Q);if(!(Q instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(Q.length===0)return"";var Z=0,j=0,D=0,G=Q.length;while(D!==G&&Q[D]===0)D++,Z++;var N=(G-D)*b+1>>>0,$=new Uint8Array(N);while(D!==G){var C=Q[D],O=0;for(var F=N-1;(C!==0||O<j)&&F!==-1;F--,O++)C+=256*$[F]>>>0,$[F]=C%W>>>0,C=C/W>>>0;if(C!==0)throw new Error("Non-zero carry");j=O,D++}var U=N-j;while(U!==N&&$[U]===0)U++;var P=Y.repeat(Z);for(;U<N;++U)P+=q.charAt($[U]);return P}function T(Q){if(typeof Q!=="string")throw new TypeError("Expected String");if(Q.length===0)return new Uint8Array;var Z=0,j=0,D=0;while(Q[Z]===Y)j++,Z++;var G=(Q.length-Z)*h+1>>>0,N=new Uint8Array(G);while(Q[Z]){var $=J[Q.charCodeAt(Z)];if($===255)return;var C=0;for(var O=G-1;($!==0||C<D)&&O!==-1;O--,C++)$+=W*N[O]>>>0,N[O]=$%256>>>0,$=$/256>>>0;if($!==0)throw new Error("Non-zero carry");D=C,Z++}var F=G-D;while(F!==G&&N[F]===0)F++;var U=new Uint8Array(j+(G-F)),P=j;while(F!==G)U[P++]=N[F++];return U}function u(Q){var Z=T(Q);if(Z)return Z;throw new Error("Non-base"+W+" character")}return{encode:m,decodeUnsafe:T,decode:u}};g.exports=n});class M extends Error{}class L extends M{constructor(){super("Cannot create snowflake due to increment overflow.")}}function B(q){let J="";for(let K of new Uint8Array(q)){if(K<16)J+="0";J+=K.toString(16)}return J}function x(q){const J=new Uint8Array(q.length/2);for(let K=0,V=0;K<q.length;K+=2,V++)J[V]=Number.parseInt(q.slice(K,K+2),16);return J.buffer}var E=c(v(),1),z=E.default("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");var R=function(q,J,K){Object.defineProperty(q,J,{value:K,enumerable:!0,writable:!1,configurable:!1})},A=1640995200000,S=1024;class H{timestamp;server_id;worker_id;increment;#q;#Q;#K;#J;#V;constructor(...q){switch(q.length){case 5:this.#W(...q);break;case 3:this.#X(...q);break;default:throw new TypeError("Invalid arguments given.")}}#W(q,J,K,V,{increment_bit_offset:X,number_server_id_worker_id:I}){const W=q-A;this.#q=new ArrayBuffer(8);const Y=new DataView(this.#q);Y.setUint32(0,Math.floor(W/S)),Y.setUint32(4,W%S<<22|J<<X|I),R(this,"timestamp",q),R(this,"server_id",K),R(this,"worker_id",V),R(this,"increment",J)}#X(q,J,{server_id_mask:K,worker_id_bits:V,worker_id_mask:X,increment_bit_offset:I}){if(q instanceof ArrayBuffer)this.#q=q;else if(Buffer.isBuffer(q))this.#q=q.buffer.slice(q.offset,q.offset+q.byteLength);else if(typeof q==="bigint")this.#q=new ArrayBuffer(8),new DataView(this.#q).setBigUint64(0,q);else if(typeof q==="string")switch(J){case"decimal":this.#q=new ArrayBuffer(8),new DataView(this.#q).setBigUint64(0,BigInt(q));break;case"hex":this.#q=x(q);break;case"base62":this.#q=z.decode(q).buffer;break}if(this.#q===void 0)throw new M(`Unknown encoding: ${J}`);const W=new DataView(this.#q),Y=W.getUint32(4);R(this,"timestamp",W.getUint32(0)*S+(Y>>>22)+A),R(this,"server_id",Y>>>V&K),R(this,"worker_id",Y&X),R(this,"increment",Y<<10>>>10>>>I)}toArrayBuffer(){return this.#q}toUint8Array(){if(!this.#Q)this.#Q=new Uint8Array(this.toArrayBuffer());return this.#Q}toBuffer(){return Buffer.from(this.toArrayBuffer())}toBigInt(){if(!this.#K)this.#K=new DataView(this.toArrayBuffer()).getBigUint64(0);return this.#K}toDecimal(){return this.toBigInt().toString()}toHex(){if(!this.#J)this.#J=B(this.toArrayBuffer());return this.#J}toBase62(){if(!this.#V)this.#V=z.encode(this.toUint8Array());return this.#V}}async function y(q){return new Promise((J)=>{setTimeout(J,q)})}class l{#q;#Q;#K=0;#J=0;#V;#W;constructor({bits:{server_id:q=7,worker_id:J=5}={},server_id:K=0,worker_id:V=0}={}){this.#q=K,this.#Q=V;const X=2**q-1,I=J,W=2**J-1;if(K<0||K>X||!Number.isInteger(K))throw new M(`Invalid server_id: ${K} (possible values: from 0 to ${X} inclusive)`);if(V<0||V>W||!Number.isInteger(V))throw new M(`Invalid worker_id: ${V} (possible values: from 0 to ${W} inclusive)`);const Y=q+J;this.#V=2**(22-Y)-1,this.#W={server_id_mask:X,worker_id_bits:I,worker_id_mask:W,increment_bit_offset:Y,number_server_id_worker_id:K<<J|V}}create(){const q=Date.now();if(q<this.#J)throw new M(`Cannot create snowflake: Date.now() has returned (probably) invalid value ${q}, but previously we got ${this.#J}, is code running on time machine?`);if(q>this.#J)this.#K=0,this.#J=q;else if(this.#K>this.#V)throw new L;return new H(q,this.#K++,this.#q,this.#Q,this.#W)}async createSafe(){for(let q=0;q<100;q++)try{return this.create()}catch(J){if(J instanceof L)await y()}throw new L}parse(q,J){return new H(q,J,this.#W)}}export{L as SnowflakeIncrementOverflowError,l as SnowflakeFactory,M as SnowflakeError,H as Snowflake};
